<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>5.Conductors</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Metals_files/libs/clipboard/clipboard.min.js"></script>
<script src="Metals_files/libs/quarto-html/quarto.js"></script>
<script src="Metals_files/libs/quarto-html/popper.min.js"></script>
<script src="Metals_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Metals_files/libs/quarto-html/anchor.min.js"></script>
<link href="Metals_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Metals_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Metals_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Metals_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Metals_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">5.Conductors</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="metals-and-their-electrical-properties" class="level2">
<h2 class="anchored" data-anchor-id="metals-and-their-electrical-properties">5.1 Metals and their electrical properties</h2>
<p>So far our treatment of Electric fields has been largely abstract and mathematical. We have pretty much taken Coulomb’s law and the superposition principle to derive the result that the mathematical divergence of our electric field is proportional to the charge density and that the curl of the field is zero meaning it is conservative. Oue examples and questions have largely depended on us defining a charge density to find the electric field or electric potential, or the electric field to find the charge density etc. We have not addressed the question about how we might generate these charge density distributions in the first place. i.e.&nbsp;How, in practice, to I place the charges in my system to obtain the desired electric field?</p>
<p>This leads us naturally to consider the <span class="math inline">\(\textit{materials}\)</span> we are using in any practical situation. In broad terms we can divide our materials in to three types; metals, insulators and semiconductors. As you will realise semiconductors are of extreme technical importance (we wouldn’t have mobile phohes without them). However, to treat them properly we need to apply a proper quantum mechanical approach, though our concepts of electric and magnetic fields will still apply. Hence in this course we will just consider conductors and insulators and a 19th century classical (non-quantum) description of their properties.</p>
<p>We will consider metals first.</p>
<section id="what-is-a-metal" class="level3">
<h3 class="anchored" data-anchor-id="what-is-a-metal">What is a metal ?</h3>
<p>Our simplest interpretation of a metal is a material in which electrical charge is free to move (under the inflence of an electric field). What does this simple statement tell us about the electric fields and charge distributions in a metal?</p>
<ul>
<li>The electrostatic field within a metal must always be zero (<span class="math inline">\(\vec{E}=0\)</span>). Why? Well, if there was an electric field in the conductor the mobile charges would move under the influence of the field (<span class="math inline">\(\vec{F}=q\vec{E})\)</span> until the consequent separation of charge produces an electric field that cancels, perfectly, the original field.</li>
<li>The charge density in a conductor is always <span class="math inline">\(\rho = 0\)</span>. This is perhaps more difficult to see. In the absence of any electric field the charge density in our metal is <span class="math inline">\(\rho =0\)</span>. This does not mean that there are no charges but rather there is an equal amount of positive and negative charge present (remember we are using a classical macroscopic description and not concerned with individual electron and nucleus charges). If an internal field was present then, as described above, the charges would move to cancel the field.</li>
<li>If the charges move to cancel the field in a metal, where do they go? Well, in the case above, if we talk about a simple metal the only reason for an internal field to be present would be due to an external field being applied. Hence, when an exteral field is applied the charges accumulate on the <span class="math inline">\(\textit{surface}\)</span> of the metal (they are not allowed to escape the metal in our basic description of a metal) in such a way as to provide the perfect cancellation of the external field within the metal itself.</li>
<li>The electric field at the surface of the metal is always normal to the surface. If it wasn’t then any field in the plane of the surface would cause the charges to move and cancel the field.</li>
<li>The electric potential at the surface of the metal must be constant. This is related to the above as if there was a difference in potential along the surface this would imply an electric field and, as noted above, charges would move to compensate the field.</li>
</ul>
</section>
</section>
<section id="metal-surfaces-define-a-point-of-constant-potential" class="level2">
<h2 class="anchored" data-anchor-id="metal-surfaces-define-a-point-of-constant-potential">5.2 Metal surfaces define a point of constant potential</h2>
<p>The observation that all points on a continuous metal surface (think plates connected with wires etc.) are at constant potential is of important practical consequence. For example, consider two metal plates that are close but not connected to each other. If the two plates are at different potential then there must be a difference in the charge on them. One will be net positive and the other negative. The net charge will distribute itself on the plates in such a way that the plates are at a constant potential. According to our knowledge of electric fields gleaned in section 2 these separated charges will give rise to an electric field. Thus we can imnagine that we can generate particular field distributions by carefully shaping and arranging metal objects. The controlling parameter is then the potential difference between the metal objects. You may still note that we still haven’t described how we produce a potential difference (for example with a battery).</p>
<p>Now let’s go back to our original definition of potential through Poisson’s and Laplace’s equations. We can find the potential and hence the electric field by solving Poisson’s equation, if we know the charge distribution that developed on our plates. However, it is much simpler to solve Laplace’s equation (<span class="math inline">\(\nabla^2 V=0\)</span>) subject to the boundary conditions that the potentials on the metals are constant.</p>
<p>In summary, provided we are able to generate potential differences on metal plates, we can find the electric field in our system by finding the solution of Laplace’s equation, subject to boundary conditions, and then calculating <span class="math inline">\(\vec{E}=-\nabla V\)</span> to obtain the field.</p>
</section>
<section id="induced-charges" class="level2">
<h2 class="anchored" data-anchor-id="induced-charges">5.3 Induced charges</h2>
<p>In section 5.2 you have seen how we have avoided the need to calculate the charge distribution. This is true of most practical situations. We don’t generally ask how much charge we need to put somewhere to generate a field, but rather how to generate surfaces of constant potential with a metal.</p>
<p>This is not to say that we can’t find the charge distributions or that it is not useful to think about charge distributions. For example, thinking about charge distributions is more helpful if we want to sketch field lines directly. The alternative is to sketch lines of constant potential and to generate field lines (i.e.&nbsp;lines perpendicular to the contours). We might also wonder what happens when an external field is applied to a metal. Well, as we saw in our description of a metal, if we apply an external field to a metal it will cause the charges to move around to cancel out the external field in the metal. We call the resultant surface charges the <span class="math inline">\(\textit{induced}\)</span> charges on the metal. The induction of charges on metal surfaces plays an important part in the way 19th century electrostatic machines (such as the Van de Graaf and Wimhurst machines work). Remember at that time there were no convenient ways of generating potential differences (such as good batteries, power supplies etc.). We don’t have time to look into the devices in detail but at their heart they rely on some random process (one material rubbing againt another) to cause a small separation of charge on a metal metal plate. Through metal connections this charge separation is used to generate a field that induces further charge separation on the plates to amplifiy the original charge separation (and hence fields). These machines are quite capable of generating potential differences in the 10,000s of volts.</p>
<p>The gold leaf electroscope, an early device for measuring potential, relies on the formation of induced charges of the same sign on two separated metal (gold) leaves. The coulomb force between the two leaves then causes them to separate - the amount of separation corresponding to the electric field/potential at measuring point,</p>
</section>
<section id="forces-on-metal-surfaces-in-electric-fields" class="level2">
<h2 class="anchored" data-anchor-id="forces-on-metal-surfaces-in-electric-fields">5.4 Forces on metal surfaces in electric fields</h2>
<p>If we think about our electric field that has induced surface charges on our metal then we would expect to see a net force to act on the surface, or better we can imagine a surface pressure (force per unit are).</p>
<p>Let’s look at how the electric field changes across a boundary. From section 4.1 we see that the field immediately outside the surface of the metal is,</p>
<p><span class="math inline">\(\displaystyle \vec{E}=\frac{\sigma}{\epsilon_0} \hat{\vec{n}}\)</span></p>
<p>and immediately inside the surface it will be zero (as its a metal). So what field do we use to calculate the force? Well we take the average,</p>
<p><span class="math inline">\(\displaystyle \vec{E_{av}}=\frac{\sigma}{2 \epsilon_0} \hat{\vec{n}}\)</span>.</p>
<p>The justification for doing this is explained in Griffiths (section 2.5.3). If we accept this then the force per unit area (remember the charge is given by <span class="math inline">\(q\sigma A\)</span> for a surface) is,</p>
<p><span class="math inline">\(\displaystyle \vec{f}=\sigma \frac{\vec{E_{av}}}{2}\)</span></p>
<p>Subsitituting for <span class="math inline">\(E_{av}\)</span> we get,</p>
<p><span class="math inline">\(\displaystyle \vec{f}=\frac{\sigma ^2}{2\epsilon_0}\hat{\vec{n}}=P=\frac{\epsilon_0}{2}E^2\)</span>,</p>
<p>where <span class="math inline">\(P\)</span> is the pressure on the surface and <span class="math inline">\(E\)</span> is the magnitude of the external field at the surface..</p>
<p>In general we don’t worry about these forces on metals in electric fields - they are rigid and strong enough to avoid deformation. However, for thin materials and/or high fields the mechanical strength of materials may impose limits on the kind of devices that may be constructed.</p>
</section>
<section id="capacitors" class="level2">
<h2 class="anchored" data-anchor-id="capacitors">5.5 Capacitors</h2>
<p>The capacitor is a very common and vital component used in electronic circuits (we’ll discuss circuits later). Fundamentally it acts as a store of charge for a given potential difference applied. The larger the capacitance the bigger the charge stored for a given potential difference.</p>
<p>Consider two metals in an overall neutral (no excess charge anywhere) system. As explained above, the surface of each conductor must be an equipotential. Now if one conductor has a net surface charge <span class="math inline">\(+Q\)</span> on it, the other (as there is charge balance) will have a net surface charge <span class="math inline">\(-Q\)</span>. By definition, the potential difference between the two conductors is given by</p>
<p><span class="math inline">\(\displaystyle \Delta V= -\int_-^+ \vec{E}.d\vec{l}\)</span></p>
<p>irrespective of where we start on the metal a and the path we take to any point on metal b. We also know that the strength of the electric field will be proportional to the total charge on a plate as,</p>
<p><span class="math inline">\(\displaystyle\vec{E}(\vec{r})=\dfrac{1}{4\pi\epsilon_0}\int\rho(\vec{r'})\dfrac{(\vec{r}-\vec{r'})}{|\vec{r}-\vec{r'}|^3}d\tau'\)</span></p>
<p>As a result, simply put</p>
<p><span class="math inline">\(\Delta V \propto Q\)</span></p>
The constant of proportionality is known as the capacitance and depends only on the geometric arrangement of the metals.
<center>
<span class="math inline">\(\displaystyle C=\frac{Q}{V} \;\; ... (5.1)\)</span>
</center>
<p>It is a quantity that can be measured quite commonly and easily with laboratory equipment or, in simple cases, calculated theoretically (the general procedure to do this is to ‘put’ equal and opposite charges on the metals, calculate the electric field between the two metals and then determine the potential difference between the two metals by integration of <span class="math inline">\(\int\vec{E}.d\vec{l}\)</span>. The <span class="math inline">\(Q\)</span> will then drop out when the ratio of <span class="math inline">\(Q/V\)</span> is found.</p>
</section>
<section id="energy-stored-in-a-capacitor" class="level2">
<h2 class="anchored" data-anchor-id="energy-stored-in-a-capacitor">5.6 Energy stored in a capacitor</h2>
<p>If we start with an uncharged capacitor, one way to work out the energy stored is to integrate the electric field over all space once its charged. Another way is to consider how much energy we need to supply to keep adding charge to our capacitor. i.e.&nbsp;if our capacitor is already charged to some potential <span class="math inline">\(V\)</span> then the energy required to add a further small charge <span class="math inline">\(dq\)</span> is just <span class="math inline">\(Vdq = (q/C)dq\)</span>. Hence the work done in adding a total charge <span class="math inline">\(Q\)</span> to our capacitor is,</p>
<p><span class="math inline">\(\displaystyle W=\int_0^Q \frac{q}{C}dq = \frac{1}{2}\frac{Q^2}{C}\)</span></p>
<p>or, in terms of the potential difference,</p>
<center>
<span class="math inline">\(\displaystyle  W=\frac{1}{2}CV^2 \;\; ... (5.2)\)</span>
</center>
<p>We will see some examples of calculating capacitance and energy stored in capacitors in lectures and problems classes.</p>
<p><a href="index.html">Return to index</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>