<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4 Electrostatic fields - boundary conditions and energy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ElectrostaticsEnergy_files/libs/clipboard/clipboard.min.js"></script>
<script src="ElectrostaticsEnergy_files/libs/quarto-html/quarto.js"></script>
<script src="ElectrostaticsEnergy_files/libs/quarto-html/popper.min.js"></script>
<script src="ElectrostaticsEnergy_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ElectrostaticsEnergy_files/libs/quarto-html/anchor.min.js"></script>
<link href="ElectrostaticsEnergy_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ElectrostaticsEnergy_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ElectrostaticsEnergy_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ElectrostaticsEnergy_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ElectrostaticsEnergy_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">4 Electrostatic fields - boundary conditions and energy</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="boundary-conditions" class="level2">
<h2 class="anchored" data-anchor-id="boundary-conditions">4.1 Boundary conditions</h2>
<p>In our consideration of electric (and magnetic) fields an important consideration is what happens to the fields as we pass across boundaries of charge distribution (or current densities). I am going to state the results here. It is not difficult to show the results using Gauss’ law and the arguments are presented in Griffiths if you wish to see the details.</p>
<p>In the most compact form we may write the boundary conditions for the electric field as,</p>
###
<center>
$<em>{above}-</em>{below} = ;; … (4.1) $
</center>
<p>where <span class="math inline">\(\hat{\vec{n}}\)</span> is the normal to the surface. In words, this says there is no change in <span class="math inline">\(\vec{E}\)</span> in the direction parallel to the surface, as I pass through the surface. On the other hand, the electric field perpendicular to surface goes through a discontinuous change (it changes sign) as you go through the surface.</p>
<p>As you approach the surface the value of the potentials above and below the surface will converge to the be same at the surface, i.e</p>
<p><span class="math inline">\(V_{above}=V_{below}\)</span></p>
<p>but if we think of the gradient of the potential at the surface (<span class="math inline">\(\nabla V\)</span>) then this is equivalent to <span class="math inline">\(\vec{E}\)</span> at the surface so for potential we have,</p>
###
<center>
<span class="math inline">\(\displaystyle \frac{\partial V_{above}}{\partial n}-\frac{\partial V_{below}}{\partial n}=-\frac{\sigma}{\epsilon_0} \;\; ... (4.2)\)</span>
</center>
<p>where we have defined the ‘normal’ derivative as,</p>
<p><span class="math inline">\(\displaystyle \frac{\partial V}{\partial n}=\nabla V.\hat{\vec{n}}\)</span></p>
<p>i.e the component of <span class="math inline">\(\nabla V\)</span> in the direction of <span class="math inline">\(\hat{\vec{n}}\)</span>.</p>
</section>
<section id="work-and-energy" class="level2">
<h2 class="anchored" data-anchor-id="work-and-energy">4.2 Work and energy</h2>
<p>From your mechanics course in the first year you will have seen that the work done against a force (and hence a store of poetential energy) is given by,</p>
<p><span class="math inline">\(\displaystyle W= \int_a^b \vec{F}.d\vec{l}\)</span></p>
<p>If we apply this the result to the work needed to move a charge in an electric field we get,</p>
<p>$W = Q_a^b .d=Q[V(b)-V(a)] = QV $</p>
<p>Hence we can also use the potential difference to describe the work done to move a charge <span class="math inline">\(Q\)</span> in the field.</p>
<p>So what is the energy stored in a distribution of point charges? Well we can imagine building up an assembly of charges by bringing each one suequentially in from infinity. There is no energy needed to bring the first charge in. For the second charge we need,</p>
<p><span class="math inline">\(\displaystyle W_2 = \frac{q_1q_2}{4\pi\epsilon_0 r_{12}}\)</span>,</p>
<p>the third one needs to do work against the other two charges (we’re OK to use superposition here as we can treat the fields from the first two charges as the sum of the individual charges), so,</p>
<p><span class="math inline">\(\displaystyle W_3 = \frac{q_3q_2}{4\pi\epsilon_0 r_{32}}+\frac{q_3q_1}{4\pi\epsilon_0 r_{31}}\)</span>,</p>
<p><span class="math inline">\(\displaystyle W_4 = \frac{q_4}{4\pi\epsilon_0}\left( \frac{q_3}{r_{43}}+\frac{q_2}{r_{42}}+\frac{q_1}{r_{41}}\right)\)</span>.</p>
<p>For <span class="math inline">\(n\)</span> charges this can be written as,</p>
<p><span class="math inline">\(\displaystyle W_{total}=\frac{1}{4\pi\epsilon_0}\sum_{i=1}^n \sum_{j\gt i}^n \frac{q_iq_j}{r_{ij}}=\frac{1}{8\pi\epsilon_0}\sum_{i=1}^n \sum_{j\ne i}^n \frac{q_iq_j}{r_{ij}}\)</span>.</p>
<p>Note, in the second expression we’ve allowed counting a pair twice (i.e.&nbsp;i-j and j-i) and adjusted by dividing the result by 2. Now we can write,</p>
<p><span class="math inline">\(\displaystyle W=\frac{1}{2}\sum_{i=1}^n q_i\left(\sum_{j,j \ne i}^n \frac{1}{4\pi\epsilon_0}\frac{q_j}{r_{ij}}\right)\)</span></p>
<p>or, finally,</p>
###
<center>
<span class="math inline">\(\displaystyle W = \frac{1}{2} \sum_{i=1}^n q_i V(\vec{r_i}) \;\; ...(4.3)\)</span>
</center>
<p>Here we note that <span class="math inline">\(V(\vec{r_i})\)</span> is the potential from all the other charges at the point <span class="math inline">\(\vec{r_i}\)</span>, the position of <span class="math inline">\(q_i\)</span>.</p>
<p>If we extend this argument to a continuous distribution of charge the 4.3 becomes</p>
###
<center>
<span class="math inline">\(\displaystyle W = \frac{1}{2}\int_{charge\, volume}\rho V\;d\tau \;\; ... (4.4)\)</span>
<center>
<section id="section" class="level3">
<h3 class="anchored" data-anchor-id="section"></h3>
<p>There is an interesting way to get the energy stored in terms of the electric field (see Griffiths section 2.4.3) to give,</p>
###
<center>
$W = _{All,space} .;d ;; … (4.5) $
<center>
</center></center></section>
<section id="section-1" class="level3">
<h3 class="anchored" data-anchor-id="section-1"></h3>
<p>or we can also write <span class="math inline">\(\vec{E}.\vec{E} = |E|^2\)</span> in the kernel of the integral.</p>
<p>So we have two ways of thinking about the way the energy is stored, as the work done in assembling the charges or as associated with the field generated (the field energy) of the charges.</p>
<p>IMPORTANT. We can’t use the superposition principle to sum energies. For example take two separate charge distributions for which we have calculated their energy as <span class="math inline">\(W_1=E_1^2\)</span> and <span class="math inline">\(W_2=E_2^2\)</span>. We might be tempted to say that bringing them together gives a total energy <span class="math inline">\(W_1+W_2\)</span>. Well there is clearly extra work done bringing them together, or in terms of the field, the new field is <span class="math inline">\(\vec{E}_{new}=\vec{E_1}+\vec{E_2}\)</span> so in 4.5 the kernel becomes <span class="math inline">\(E_{new}^2\)</span> which is not the same as <span class="math inline">\((\vec{E_1}+\vec{E_2}).(\vec{E_1}+\vec{E_2})=E_1^2+E_2^2 +2\vec{E_1}.\vec{E_2}\)</span> where the cross term is not zero.</p>
<p><a href="index.html">Return to index</a></p>
</section>
</center></center></section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>