<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3. Electric potential</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ElectricPotential_files/libs/clipboard/clipboard.min.js"></script>
<script src="ElectricPotential_files/libs/quarto-html/quarto.js"></script>
<script src="ElectricPotential_files/libs/quarto-html/popper.min.js"></script>
<script src="ElectricPotential_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ElectricPotential_files/libs/quarto-html/anchor.min.js"></script>
<link href="ElectricPotential_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ElectricPotential_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ElectricPotential_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ElectricPotential_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ElectricPotential_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">3. Electric potential</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In the previous section we derived the equations that define the electrostatic field in terms of the distribution of the electric charges in the system. This arose naturally by starting from Coulomb’s law for the force of attraction between two charged particles. However, in general terms they are of limited use as, to obtain a desired electric field we need to not only calculate where the charge distribution needs to be but we also need to know how we would achieve this in practise. We might also ask how we might expect to get stable charge densities. If I have a positive charge density what would stop the indvidual charges in the system blowing itself apart? In a sense our examples were quite contrived as we never explained how we generated the charge distribution in the first place!</p>
<p>To make progress, we are going to introduce a new property of the Electrostatic field - the Electric potential. You should already be familiar with this concept but we will now apply some of the mathematics you have now learnt to decribe the electric potential in a more succint and concise form.</p>
<section id="the-electrostatic-potential" class="level2">
<h2 class="anchored" data-anchor-id="the-electrostatic-potential">3.1 The electrostatic potential</h2>
<p>In section 2 we showed that <span class="math inline">\(\vec{E}\)</span> is a conservative field. Hence, we can apply the properties of such fields to define the electrostatic potential,</p>
<p><span class="math inline">\(\displaystyle V(\vec{a}) = -\int_O ^\vec{a}\vec{E}.d\vec{l}\)</span>.</p>
<p>Note, this should not be confused with potential energy (that we will discuss later). Note also the minus sign. We can also see that value of <span class="math inline">\(V(a)\)</span> will depend on our choice of origin <span class="math inline">\(O\)</span> - i.e.&nbsp;it is not really possible to define an <span class="math inline">\(\textit{absolute}\)</span> value of potential.</p>
<p>However, the <span class="math inline">\(\textit{potential difference}\)</span> between two points <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> is of importance so let’s see what we mean by potential difference.</p>
<p>We can write the potental diffirence between two points as follows,</p>
<p><span class="math inline">\(\displaystyle V(\vec{b})-V(\vec{a}) = - \int_O^\vec{b} \vec{E}.d\vec{l}+\int_O^\vec{a}\vec{E}.d\vec{l}\)</span></p>
<p>or</p>
<p><span class="math inline">\(\displaystyle V(\vec{b})-V(\vec{a}) = - \int_O^\vec{b} \vec{E}.d\vec{l}-\int_\vec{a}^O\vec{E}.d\vec{l}\)</span></p>
<p>so that</p>
<center>
<span class="math inline">\(\displaystyle V(\vec{b})-V(\vec{a}) = - \int_{\vec{a}}^{\vec{b}}\vec{E}.d\vec{l}\;\; ... (3.1)\)</span>
</center>
<p>Now, we note, again remembering the property of conservative fields, that this line integral is independent of the path taken or any chosen zero of potential.</p>
</section>
<section id="the-electric-field-expressed-as-the-gradient-of-a-scalar-potential" class="level2">
<h2 class="anchored" data-anchor-id="the-electric-field-expressed-as-the-gradient-of-a-scalar-potential">3.2 The electric field expressed as the gradient of a scalar potential</h2>
<p>In your mathematics course you will have seen seen the result,</p>
<p><span class="math inline">\(\displaystyle \int_a^b \nabla \phi.d\vec{l}=-\int_a^b\vec{X}.d\vec{l}\)</span></p>
<p>where <span class="math inline">\(\phi\)</span> is a scalar quantity (a scalar field) that gives rise to the vector quantity (vector field) <span class="math inline">\(\nabla\phi\)</span>. If we apply this result to the electrostatic field we obtain the result.</p>
<center>
<span class="math inline">\(\displaystyle \vec{E}(\vec{r})=-\nabla V(\vec{r}) \;\; ... (3.2)\)</span>
</center>
<section id="some-comments-about-the-scalar-potential." class="level3">
<h3 class="anchored" data-anchor-id="some-comments-about-the-scalar-potential.">3.2.1 Some comments about the scalar potential.</h3>
<p>Finding scalar fields (potentials) is easier than finding vector fields as we only have one component (the scalar) to find rather than the three components of a vector.</p>
<p>Note the concept of the potential, only applies to conservative fields, there is no absolute definition of potential - we can only find differences in potential. We can define our position of zero potential in an arbitary way (as we only need differences in potential) and potentials obey the principle of superposition (i.e.&nbsp;<span class="math inline">\(V=V_1+V_2+V_3 +\)</span>).</p>
<p>The S.I. unit of potential is <span class="math inline">\(J\cdot C^{-1}\)</span> or <span class="math inline">\(N\cdot m\cdot C^{-1}\)</span> that is given the name Volt.</p>
<p>You should be very familiar with the Volt, it is a unit people use everyday (think batteries, power supplies …). It maybe gives a hint as to the importance of the potential in electrical and electronic systems.</p>
</section>
</section>
<section id="poissons-equation." class="level2">
<h2 class="anchored" data-anchor-id="poissons-equation.">3.2 Poisson’s equation.</h2>
<p>With our knowledge of vector calculus we can very quickly find the relationship between the charge density and the potential</p>
<p><span class="math inline">\(\displaystyle \nabla.\vec{E}=-\nabla. \nabla V = -\nabla^2V=\frac{\rho}{\epsilon_0}\)</span></p>
<p>From this we find <span class="math inline">\(\textit{Poisson's equation}\)</span>,</p>
<center>
<span class="math inline">\(\displaystyle \nabla^2V(\vec{r})=-\frac{\rho(\vec{r})}{\epsilon_0} \;\; ... (3.3)\)</span>
</center>
</section>
<section id="laplaces-equation" class="level2">
<h2 class="anchored" data-anchor-id="laplaces-equation">3.3 Laplace’s equation</h2>
<p>In regions of space where there are no charges (such that <span class="math inline">\(\rho(\vec{r})=0\)</span> Poisson’s equation reduces to,</p>
<center>
<span class="math inline">\(\displaystyle \nabla^2 V(\vec{r})=0 \;\; ... (3.4)\)</span>
</center>
<p>that is known as <span class="math inline">\(\textit{Laplace's equation}\)</span>.</p>
<p>It is perhaps not obvious why equations 3.3 and 3.4 are any more useful than calculating <span class="math inline">\(\vec{E}\)</span> directly from the charge distribution. i.e.&nbsp;we have just substituted a first order vector equation for a second order scalar equation. We will discuss potentials in more detail shortly but, you will see (or you have seen already), that in the world around us metals are equipotentals. We can change the potential of a metal component with, for example, a battery, so we can have two pieces of metal at different potentials if we connect them to different sides of our battery . These metal surfaces, at different potentials, provide the boundary conditions for equation 3.3. Therefore the potential determines the charge density and the electric field due to our metal surfaces. This is much more useful and practical and we’ll see why this works later.</p>
</section>
<section id="the-general-solution-to-poissons-equation" class="level2">
<h2 class="anchored" data-anchor-id="the-general-solution-to-poissons-equation">3.4 The general solution to Poisson’s equation</h2>
<p>As we discussed in the previous section, it is the potential that is most easily controlled in the world around us. So, if we know the potential we can calculate the field without needing to know the charge density. Nevertheless, if we know the charge density distribution we can calculate the electric potential directly. The result for the general solution of Poisson’s equation is,</p>
<center>
<span class="math inline">\(\displaystyle V(\vec{r})=\frac{1}{4\pi\epsilon_0}\int_V \frac{\rho(\vec{r'})}{|\vec{r}-\vec{r'}|}d\tau '\;\;...(3.5)\)</span>
</center>
<p>Although I haven’t formally proved this result, you should be able to see how it can be obtained from the potential of single point charge (that I leave you to show),</p>
<p><span class="math inline">\(\displaystyle V(\vec{r})=\frac{1}{4\pi\epsilon_0}\frac{q}{r}\)</span></p>
<p>and then using the principle of super position and spatial averaging to generate the integral over a continuous charge distribution. (The method is similar to the arguments we used for the electric field). Note also in the case of line (<span class="math inline">\(\lambda)\)</span>) and surface (<span class="math inline">\(\sigma\)</span>) charge densities we may use the equivalent results,</p>
<p><span class="math inline">\(\displaystyle V(\vec{r})=\frac{1}{4\pi\epsilon_0}\int_{path}\frac{\lambda(\vec{r'})}{|\vec{r}-\vec{r'}|})dl'\)</span></p>
<p>and</p>
<p><span class="math inline">\(\displaystyle V(\vec{r})=\frac{1}{4\pi\epsilon_0}\int_{surface}\frac{\sigma(\vec{r'})}{|\vec{r}-\vec{r'}|}da'\)</span></p>
<section id="electric-field-and-potential-summary" class="level3">
<h3 class="anchored" data-anchor-id="electric-field-and-potential-summary">3.5 Electric field and potential summary</h3>
<p>At this point we can summarise our knowledge of Electrostatics in the following triangle of relationships.</p>
<center>
<img src="images/rho_V_E.jpg" alt="Rho V and E relationships" width="500">
</center>
<p>With these and given, either <span class="math inline">\(\rho\)</span>, <span class="math inline">\(\vec{E}\)</span> or <span class="math inline">\(V\)</span> it is possible to derive the other two quantities. However, apart from simple cases, of which a few will be given in the lectures, it is not easy to solve the various integrals to find <span class="math inline">\(\vec{E}\)</span> or <span class="math inline">\(V\)</span>. For the electric field you will find you will either use Gauss’ law for highly symmetric charge distributions or the integral methods where it is possible to cast the solution in terms of an analytically solvable integral (again largely in cases of symmetrical charge distributions). If this is not possible you can revert to numerical methods. For the case of the electric potential there are a few other useful methods that we will explore in more detail later. Remember also you can apply the superposition principle.</p>
<p><a href="index.html">Return to index</a></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>